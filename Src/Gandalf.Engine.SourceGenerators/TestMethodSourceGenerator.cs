
// <auto-generated />
#nullable enable
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Gandalf.Engine.SourceGenerators.Helpers;

namespace Gandalf.Engine.SourceGenerators;

/// <summary>
/// Gandalf's TestMethodSourceGenerator discovers and registers all [Test] methods at compile time.
/// </summary>
[Generator]
public class TestMethodSourceGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all method declarations in the syntax tree
        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is MethodDeclarationSyntax,
                transform: (ctx, _) => (MethodDeclarationSyntax)ctx.Node)
            .Where(static m => m is not null);

        // Combine with the compilation for semantic analysis
        var compilationAndMethods = context.CompilationProvider.Combine(methodDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndMethods, static (spc, source) =>
        {
            try
            {
                var (compilation, methods) = source;
                // Group methods by containing class
                var methodsByClass = methods
                    .Select(m => (Method: m, Symbol: compilation.GetSemanticModel(m.SyntaxTree).GetDeclaredSymbol(m)))
                    .Where(t => t.Symbol is not null && SourceGenAttributeHelpers.HasTestAttribute(t.Symbol))
                    .GroupBy(t => t.Symbol!.ContainingType, SymbolEqualityComparer.Default);

                // First pass: collect all scoped groups across all classes
                var allScopedGroups = new Dictionary<string, (string typeName, string groupVarName)>();
                foreach (var classGroup in methodsByClass)
                {
                    var classSymbol = classGroup.Key;
                    if (classSymbol is null) continue;
                    
                    var injectProperties = (classSymbol as INamedTypeSymbol)?.GetMembers()
                        .OfType<IPropertySymbol>()
                        .Where(p => p.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == "Gandalf.Core.Attributes.InjectAttribute"))
                        .ToList() ?? [];

                    var scopedGroups = injectProperties
                        .Select(prop => {
                            var injectAttr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "Gandalf.Core.Attributes.InjectAttribute");
                            var instanceTypeValue = injectAttr?.ConstructorArguments.Length > 0 ? injectAttr.ConstructorArguments[0].Value : 0;
                            var instanceTypeInt = instanceTypeValue switch
                            {
                                int i => i,
                                _ when int.TryParse(instanceTypeValue?.ToString(), out var parsed) => parsed,
                                _ => 0
                            };
                            var scopeGroupAttr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "Gandalf.Core.Attributes.ScopeGroupAttribute");
                            var groupName = scopeGroupAttr != null && scopeGroupAttr.ConstructorArguments.Length > 0
                                ? scopeGroupAttr.ConstructorArguments[0].Value?.ToString()
                                : null;
                            return new { prop, instanceTypeInt, groupName };
                        })
                        .Where(x => x.instanceTypeInt == 1)
                        .GroupBy(x => x.groupName ?? x.prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));

                    foreach (var group in scopedGroups)
                    {
                        var typeName = group.First().prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var groupVarName = group.Key.Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(":", "_");
                        allScopedGroups[group.Key] = (typeName, groupVarName);
                    }
                }

                // Generate shared scoped class if there are any scoped groups
                if (allScopedGroups.Count > 0)
                {
                    var sharedScopedClassFields = allScopedGroups.Values
                        .Select(x => $"public static {x.typeName} {x.groupVarName}_sharedScoped = new {x.typeName}();")
                        .ToList();

                    // Create a deterministic hash of the field content to make the class name unique
                    var contentHash = string.Join("|", sharedScopedClassFields.OrderBy(x => x)).GetHashCode().ToString("X");
                    var className = $"GandalfSharedScopedInstances_{contentHash}";

                    var sharedScopedClassCode = $@"// <auto-generated />
// Shared scoped instances for Gandalf tests
using System;

namespace Gandalf.Tests.SharedScoped
{{
    public static class {className}
    {{
        {string.Join("\n        ", sharedScopedClassFields)}
    }}
}}";
                    spc.AddSource($"{className}.g.cs", sharedScopedClassCode);
                }

                // Second pass: generate test classes
                foreach (var classGroup in methodsByClass)
                {
                    var classSymbol = classGroup.Key;
                    if (classSymbol is null) continue;
                    var ns = classSymbol.ContainingNamespace.ToDisplayString();
                    var safeNamespace = string.IsNullOrEmpty(ns) ? "Gandalf.Generated" : ns;
                    var cls = classSymbol.Name;
                    var safeClassName = $"{cls}_Discovered_Tests";
                    var fqType = classSymbol.ToDisplayString();
                    var assembly = classSymbol.ContainingAssembly.Name;
                    var allRegistrations = new List<string>();

                    // Find properties with [Inject] attribute
                    var injectProperties = (classSymbol as INamedTypeSymbol)?.GetMembers()
                        .OfType<IPropertySymbol>()
                        .Where(p => p.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == "Gandalf.Core.Attributes.InjectAttribute"))
                        .ToList() ?? [];

                    // Generate test registrations
                    foreach (var (method, symbol) in classGroup)
                    {
                        if (symbol is null) continue;
                        var (startLine, startCharacter, endLine, endCharacter) = GetLineInfo(method);
                        var methodName = method.Identifier.Text;
                        var filePath = method.SyntaxTree.FilePath;

                        // If this method has argument attributes, create parameterized tests
                        var argumentAttributes = symbol.GetAttributes()
                            .Where(a => a.AttributeClass?.ToDisplayString() == "Gandalf.Core.Attributes.ArgumentAttribute")
                            .ToList();

                        var registrations = argumentAttributes.Count > 0
                            ? GenerateParameterizedTestRegistrations(symbol, argumentAttributes, fqType, ns, cls, methodName, assembly, filePath, startLine, startCharacter, endLine, endCharacter)
                            : GenerateStandardTestRegistration(symbol, fqType, ns, cls, methodName, assembly, filePath, startLine, startCharacter, endLine, endCharacter);
                        allRegistrations.AddRange(registrations);
                    }

                        var registrationBlock = string.Join("\n            ", allRegistrations);

                    // Generate declarations for injected properties
                    var injectDeclarations = new List<string>();
                    
                    // Handle scoped properties using shared instances from allScopedGroups
                    var scopedGroups = injectProperties
                        .Select(prop => {
                            var injectAttr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "Gandalf.Core.Attributes.InjectAttribute");
                            var instanceTypeValue = injectAttr?.ConstructorArguments.Length > 0 ? injectAttr.ConstructorArguments[0].Value : 0;
                            var instanceTypeInt = instanceTypeValue switch
                            {
                                int i => i,
                                _ when int.TryParse(instanceTypeValue?.ToString(), out var parsed) => parsed,
                                _ => 0
                            };
                            var scopeGroupAttr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "Gandalf.Core.Attributes.ScopeGroupAttribute");
                            var groupName = scopeGroupAttr != null && scopeGroupAttr.ConstructorArguments.Length > 0
                                ? scopeGroupAttr.ConstructorArguments[0].Value?.ToString()
                                : null;
                            return new { prop, instanceTypeInt, groupName };
                        })
                        .Where(x => x.instanceTypeInt == 1)
                        .GroupBy(x => x.groupName ?? x.prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));

                    // For each property, assign to the shared instance if in a group
                    foreach (var group in scopedGroups)
                    {
                        var groupKey = group.Key;
                        if (allScopedGroups.ContainsKey(groupKey))
                        {
                            var groupVarName = allScopedGroups[groupKey].groupVarName;
                            // Create the same hash as used for the class name
                            var allFields = allScopedGroups.Values
                                .Select(x => $"public static {x.typeName} {x.groupVarName}_sharedScoped = new {x.typeName}();")
                                .OrderBy(x => x);
                            var contentHash = string.Join("|", allFields).GetHashCode().ToString("X");
                            var className = $"GandalfSharedScopedInstances_{contentHash}";
                            
                            foreach (var t in group)
                            {
                                var varName = char.ToLowerInvariant(t.prop.Name[0]) + t.prop.Name.Substring(1);
                                injectDeclarations.Add($"var {varName} = Gandalf.Tests.SharedScoped.{className}.{groupVarName}_sharedScoped;");
                            }
                        }
                    }

                    // Handle singleton registration only once per type
                    var registeredSingletonTypes = new HashSet<string>();
                    foreach (var prop in injectProperties)
                    {
                        var varName = char.ToLowerInvariant(prop.Name[0]) + prop.Name.Substring(1);
                        var typeName = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var injectAttr = prop.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "Gandalf.Core.Attributes.InjectAttribute");
                        var instanceTypeValue = injectAttr?.ConstructorArguments.Length > 0
                            ? injectAttr.ConstructorArguments[0].Value
                            : 0;
                        var instanceTypeInt = instanceTypeValue switch
                        {
                            int i => i,
                            _ when int.TryParse(instanceTypeValue?.ToString(), out var parsed) => parsed,
                            _ => 0
                        };
                        if (instanceTypeInt == 2) // Singleton
                        {
                            if (!registeredSingletonTypes.Contains(typeName))
                            {
                                injectDeclarations.Add($"Gandalf.Core.Helpers.TestDependencyInjection.RegisterDependency<{typeName}>(new {typeName}());");
                                registeredSingletonTypes.Add(typeName);
                            }
                            injectDeclarations.Add($"var {varName} = Gandalf.Core.Helpers.TestDependencyInjection.GetDependency<{typeName}>();");
                        }
                        // Transient dependencies will be created inline in each test's object initializer
                    }
                    var injectBlock = string.Join("\n            ", injectDeclarations);

                    var code = $@"// <auto-generated />
// This file was generated by Gandalf's TestMethodSourceGenerator.
using System;
using System.Runtime.CompilerServices;
using Gandalf.Core.Helpers;
using Gandalf.Core.Models;

namespace {safeNamespace}
{{
    /// <summary>Auto-generated test registration for {fqType}.</summary>
    public static class {safeClassName}
    {{
        [ModuleInitializer]
        public static void Initialize()
        {{
            {injectBlock}
            {registrationBlock}
        }}
    }}
}}";
                    var fileName = $"{assembly}.{cls}.DiscoveredTests.g.cs";
                    spc.AddSource(fileName, code);
                }
            }
            catch (Exception ex)
            {
                // Emit a diagnostic if the generator fails
                var descriptor = new DiagnosticDescriptor(
                    id: nameof(TestMethodSourceGenerator),
                    title: "TestMethodSourceGenerator Failure",
                    messageFormat: $"TestMethodSourceGenerator failed: {ex.Message}",
                    category: "Gandalf.SourceGen",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true);
                spc.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None));
            }
        });
    }


        /// <summary>
        /// Gets the line and character info for a method declaration.
        /// </summary>
        private static (int startLine, int startCharacter, int endLine, int endCharacter) GetLineInfo(MethodDeclarationSyntax method)
        {
            var location = method.Identifier.GetLocation();
            var lineSpan = location.GetLineSpan();
            return (
                lineSpan.StartLinePosition.Line + 1,
                lineSpan.StartLinePosition.Character + 1,
                lineSpan.EndLinePosition.Line + 1,
                lineSpan.EndLinePosition.Character + 1
            );
        }


        /// <summary>
        /// Generates registration code for a standard (non-parameterized) test method.
        /// </summary>
        private static List<string> GenerateStandardTestRegistration(
            IMethodSymbol symbol, string fqType, string ns, string cls, string methodName,
            string assembly, string filePath, int startLine, int startCharacter, int endLine, int endCharacter)
        {
            var testUid = $"{ns}.{cls}.{methodName}";
            var callArguments = SourceGenCodeHelpers.BuildCallArguments(symbol.Parameters);
            var callArgsString = string.Join(", ", callArguments);
            var objInitializer = SourceGenCodeHelpers.BuildInjectedObjectInitializer(symbol.ContainingType);
            // Extract categories and ignore reason
            var (categories, ignoreReason) = SourceGenAttributeHelpers.ExtractCategoriesAndIgnore(symbol);
            var categoriesArray = categories.Count == 0
                ? "null"
                : "new string[] { " + string.Join(", ", categories.Select(c => $"\"{c.Replace("\\", "\\\\").Replace("\"", "\\\"")}\"")) + " }";
            var invokeAsync = $"async () => await new {fqType}{objInitializer}.{methodName}({callArgsString})";
            var ignoreReasonCode = ignoreReason == null ? "null" : $"\"{ignoreReason.Replace("\\", "\\\\").Replace("\"", "\\\"")}\"";
            var code = $"DiscoveredTests.Register(new DiscoveredTest(\"{testUid.Replace("\"", "\\\"")}\", \"{assembly.Replace("\"", "\\\"")}\", \"{ns.Replace("\"", "\\\"")}\", \"{cls.Replace("\"", "\\\"")}\", \"{methodName.Replace("\"", "\\\"")}\", {invokeAsync}, \"{filePath.Replace("\"", "\\\"")}\", {startLine}, {startCharacter}, {endLine}, {endCharacter}, null, null, {categoriesArray}, {ignoreReasonCode}));";
            return new List<string> { code };
        }

        /// <summary>
        /// Generates registration code for parameterized test methods.
        /// </summary>
        private static List<string> GenerateParameterizedTestRegistrations(
            IMethodSymbol symbol, List<AttributeData> argumentAttributes, string fqType, string ns, string cls, string methodName,
            string assembly, string filePath, int startLine, int startCharacter, int endLine, int endCharacter)
        {
            var registrations = new List<string>();
            var parameters = symbol.Parameters.ToList();
            var parentUid = $"{ns}.{cls}.{methodName}";
            int count = 0;
            var objInitializer = SourceGenCodeHelpers.BuildInjectedObjectInitializer(symbol.ContainingType);
            // Extract categories and ignore reason
            var (categories, ignoreReason) = SourceGenAttributeHelpers.ExtractCategoriesAndIgnore(symbol);
            var categoriesArray = categories.Count == 0
                ? "null"
                : "new string[] { " + string.Join(", ", categories.Select(c => $"\"{c.Replace("\\", "\\\\").Replace("\"", "\\\"")}\"")) + " }";
            var ignoreReasonCode = ignoreReason == null ? "null" : $"\"{ignoreReason.Replace("\\", "\\\\").Replace("\"", "\\\"")}\"";
            foreach (var argAttr in argumentAttributes)
            {
                var args = argAttr.ConstructorArguments.FirstOrDefault();
                var argList = args.Values.Select(v =>
                    v.Kind == TypedConstantKind.Primitive
                        ? v.Value is string s ? $"\"{s}\"" : v.Value?.ToString() ?? "null"
                        : v.ToCSharpString()
                ).ToArray();
                var callArguments = SourceGenCodeHelpers.BuildCallArguments(parameters, argList);
                var callArgsString = string.Join(", ", callArguments);
                var invokeAsync = $"async () => await new {fqType}{objInitializer}.{methodName}({callArgsString})";
                var childUid = $"{ns}.{cls}.{methodName}-{count}";
                var argString = string.Join(", ", argList);
                var reg = $"DiscoveredTests.Register(new DiscoveredTest(\"{childUid}\", \"{assembly}\", \"{ns}\", \"{cls}\", \"{methodName}\", {invokeAsync}, \"{filePath}\", {startLine}, {startCharacter}, {endLine}, {endCharacter}, new object[] {{ {argString} }}, \"{parentUid}\", {categoriesArray}, {ignoreReasonCode}));";
                registrations.Add(reg);
                count++;
            }
            return registrations;
        }
    }